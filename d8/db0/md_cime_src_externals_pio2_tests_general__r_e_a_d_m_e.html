<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAM6: Using the testing framework</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CAM6
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Using the testing framework </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>PIO uses a custom testing framework (<code>&lt;PIO_SOURCE_DIR&gt;/tests/general/util/*</code>) to generate tests in the <code>&lt;PIO_SOURCE_DIR&gt;/tests/general</code> directory. The testing framework provides,</p>
<ul>
<li>Faster creation of tests : Easier creation of tests from simple stub source</li>
<li>Improved testcase code readability : Most of the boiler plate code is generated by the framework</li>
<li>Better error checking and reporting : User friendly parallel asserts</li>
<li>More testing with less code : Templated tests, auto generation of boiler plate PIO code</li>
<li>Easy integration with CTest</li>
</ul>
<h1><a class="anchor" id="autotoc_md37"></a>
Writing a test</h1>
<h2><a class="anchor" id="autotoc_md38"></a>
Testcase format</h2>
<p>All testcases recognized by the framework need to be subroutines with the following tags to indicate the start and end of the procedure,</p>
<ul>
<li><code>PIO_TF_AUTO_TEST_SUB_BEGIN</code> : This tag is used in the first line of the subroutine definition followed by the subroutine name. Consider this tag as the replacement of the <code>SUBROUTINE</code> keyword in Fortran</li>
<li><p class="startli"><code>PIO_TF_AUTO_TEST_SUB_END</code> : This tag marks the end of the subroutine, like the <code>"END SUBRTOUINE"</code> keyword in Fortran. This tag is followed by the subroutine name.</p>
<p class="startli">A simple hello world test program is shown below,</p>
<p class="startli">PIO_TF_AUTO_TEST_SUB_BEGIN hellow</p>
<p class="startli">print *, "Hello world"</p>
<p class="startli">PIO_TF_AUTO_TEST_SUB_END hellow</p>
<p class="startli">The testing framework converts this stub into a Fortran subroutine. The testing framework also adds a test driver that includes necessary code to initialize (and finalize) MPI, PIO and includes calls to all testcases tagged with the <code>PIO_TF_AUTO_TEST_SUB_BEGIN/PIO_TF_AUTO_TEST_SUB_END</code> tags.</p>
<p class="startli">Fortran code in the stub source file that don't have <code>PIO_TF_AUTO_TEST_SUB_BEGIN/PIO_TF_AUTO_TEST_SUB_END</code> tags are not modified by the framework. A test function cannot call other test functions but can call other Fortran utility functions and subroutines. It is however recommended that these utility functions return error codes that can be interpreted by a test function using a parallel assert provided by the framework (to signal a failure in these utility functions).</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md39"></a>
Runtime environment</h2>
<p>The framework also adds code to read command line arguments to set,</p>
<ul>
<li>PIO Stride : Set via "--pio-tf-stride" command line option</li>
<li>Number of PIO I/O tasks : Set via "--pio-tf-num-io-tasks" command line option</li>
<li>Number of PIO aggregators : Set via "--pio-tf-num-aggregators" command line option</li>
<li><p class="startli">PIO logging level : Set via "--pio-tf-log-level" command line option</p>
<p class="startli">The above options allow us to run the same test with different PIO parameters.</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md40"></a>
Testcase utils</h2>
<p>The following utilities are available from the framework,</p>
<ul>
<li>PIO_TF_CHECK_VAL : Check if two variables are equal. This macro allows checking between two real/integer/double values or arrays. It also allows checking if all the values in an array is equal to a scalar value. <pre class="fragment"> PIO_TF_CHECK_VAL(scalar_var1, scalar_var2)
 PIO_TF_CHECK_VAL(array1, array2)
 PIO_TF_CHECK_VAL(array1, scalar_var1)
</pre></li>
<li><code>PIO_TF_CHECK_ERR</code> : Macro used to check the return code from a PIO function. The format for the macro is shown below, <pre class="fragment">  PIO_TF_CHECK_ERR(pio_return_code, `&lt;ERROR MSG&gt;`)
</pre></li>
<li><code>PIO_TF_PASSERT</code> : A parallel assert macro. The format is shown below, <pre class="fragment">  PIO_TF_PASSERT(`&lt;LOGICAL COND&gt;`, `&lt;ERROR MSG&gt;`)
</pre></li>
<li><code>PIO_TF_ASSERT</code> : An assert (not parallel, local to each process) macro. The format is shown below, <pre class="fragment">  PIO_TF_ASSERT(`&lt;LOGICAL COND&gt;`, `&lt;ERROR MSG&gt;`)
</pre></li>
<li><code>PIO_TF_LOG</code> : Allows logging info into stdout <pre class="fragment">  PIO_TF_LOG(*,*)(`&lt;LOG MSG&gt;`)
</pre></li>
<li><code>PIO_TF_ERROR</code> : Used to flag fatal errors <pre class="fragment">  PIO_TF_ERROR(`&lt;ERROR MSG&gt;`)
</pre></li>
<li><code>pio_tf_world_sz_, pio_tf_world_rank_</code> : Variables that provide size and rank of each process.</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
Templated testcases</h2>
<p>Testcases can be templated for the different types supported by PIO. The framework provides a mapped collection of recognized fortran types and the corresponding PIO types. Templated testcases precede with a <code>PIO_TF_TEMPLATE&lt;&gt;</code> tag as show below,</p>
<p>PIO_TF_TEMPLATE&lt;PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE&gt; PIO_TF_AUTO_TEST_SUB_BEGIN templated_hellow</p>
<p>PIO_TF_FC_DATA_TYPE, dimension(10) :: buf ...</p>
<p>call PIO_initdecomp(pio_tf_iosystem_, PIO_TF_DATA_TYPE, dims, compdof, iodesc)</p>
<p>...</p>
<p>PIO_TF_AUTO_tEST_SUB_END templated_hellow</p>
<p>For the code shown above the framework generates multiple Fortran subroutines by replacing <code>PIO_TF_FC_DATA_TYPE</code> and <code>PIO_TF_DATA_TYPE</code> with matching Fortran and PIO types respectively.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Building a testcase</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
Generating the testcase</h2>
<p>Testcases are generated by the '&lt;PIO_SOURCE_DIR&gt;/tests/general/util/pio_tf_f90gen.pl' utility. It parses the stub source code provided as a command line argument and generates Fortran test cases (with all the boiler plate code necessary). The utility can be run as shown below,</p>
<pre class="fragment">./util/pio_tf_f90gen.pl --annotate-source --out=hellow.F90 hellow.F90.in
</pre><p>In the above command hellow.F90.in is the stub test case created by the developer, and the pio_tf_f90gen.pl utility creates hellow.F90, the test case. The newly generated testcase (hellow.F90) is a Fortran program that depends only on '&lt;PIO_SOURCE_DIR&gt;/tests/general/util/pio_tutil.F90' to build and contains all the code required to run the tests in it.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Building the generated testcase</h2>
<p>The test case generated is a Fortran program that depends only on '&lt;PIO_SOURCE_DIR&gt;/tests/general/util/pio_tutil.F90" to build. The test case can be built using any MPI compiler wrapper (mpif90).

 The previous two steps are incorporated into CMakeLists.txt to add a new test to the testsuite.

@section autotoc_md45 Running the testcase

@subsection autotoc_md46 Running the test suite on your laptop
 The test suite can be run by invoking the "ctest" command from the PIO build directory

@subsection autotoc_md47 Running the test suite on Supercomputers/Clusters

 TODO

@subsection autotoc_md48 Running a single test on your laptop
 A single test can be run by passing the test executable to an MPI job launcher (mpiexec), similar to running any MPI program.

    mpiexec -n 4 ./hellow

@section autotoc_md49 Adding a test into the test suite
 The build and running steps need to be incorporated into CMakeLists.txt to add a new testcase into the test suite. Please modify &lt;tt&gt;\&lt;PIO_SOURCE_DIR\&gt;/tests/general/CMakeLists.txt&lt;/tt&gt; as suggested below to add a new test to the test suite,

* Add the testcase stub source into &lt;tt&gt;GENERATED_SRCS&lt;/tt&gt;
* Add a CMake build step : To generate the test executable
@iverbatim 
  add_executable (pio_init_finalize EXCLUDE_FROM_ALL 
      pio_init_finalize.F90
      ${CMAKE_CURRENT_SOURCE_DIR}/util/pio_tutil.F90)
  target_link_libraries (pio_init_finalize piof)
  add_dependencies (tests pio_init_finalize)
@endiverbatim
* Use CMake user defined macro add_mpi_test (or add_test() for mpi-serial) to run the test
@iverbatim 
  add_mpi_test(init_finialize_1_proc
          EXECUTABLE ${CMAKE_CURRENT_BINARY_DIR}/pio_init_finalize
          NUMPROCS 1
          TIMEOUT ${DEFAULT_TEST_TIMEOUT})
@endiverbatim
@section autotoc_md50 Debugging failed tests

* Run the test suite using ctest with the "--verbose" option. This outputs a lot of information from the testing framework (to stdout), including the various tests run and the reason for failure. All information in the output from the PIO testing framework is prepended with the &lt;tt&gt;PIO_TF:&lt;/tt&gt; tag. To run a single failing test use the "-R" option available with ctest (e.g. To only run "pio_iosystem_tests3", ctest &ndash;verbose -R pio_iosystem_tests3).</p><ul>
<li>Run the failing test manually (using the MPI job launcher) and debug it. Also consider running the test with PIO log level &gt; 0 (mpiexec -n 4 ./tests/general/pio_iosystem_tests3 &ndash;pio-tf-log-level=6) </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
